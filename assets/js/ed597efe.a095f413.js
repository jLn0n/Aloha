"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7687],{60027:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new mutex instance","params":[],"returns":[{"desc":"A new mutex instance","lua_type":"Mutex"}],"function_type":"static","source":{"line":30,"path":"../Aloha/Aloha/Util/Mutex.luau"}},{"name":"Lock","desc":"Locks the mutex. If already locked, yields the current coroutine until unlocked.","params":[{"name":"prepend","desc":"Whether to prepend the coroutine to the wait queue","lua_type":"boolean"}],"returns":[],"function_type":"method","source":{"line":42,"path":"../Aloha/Aloha/Util/Mutex.luau"}},{"name":"Unlock","desc":"Unlocks the mutex and resumes the next waiting coroutine if any","params":[],"returns":[{"desc":"Returns true if a coroutine was resumed, nil otherwise","lua_type":"boolean?"}],"function_type":"method","source":{"line":61,"path":"../Aloha/Aloha/Util/Mutex.luau"}},{"name":"UnlockAfter","desc":"Creates a timer that unlocks the mutex after the specified delay","params":[{"name":"delay","desc":"Delay in seconds before unlocking","lua_type":"number"}],"returns":[{"desc":"Timer instance that will unlock the mutex after the delay","lua_type":"Timer"}],"function_type":"method","source":{"line":78,"path":"../Aloha/Aloha/Util/Mutex.luau"}}],"properties":[],"types":[],"name":"Mutex","desc":"A mutex (mutual exclusion) implementation for coroutine synchronization. Based on SinisterRectus\'s implementation in Discordia.","source":{"line":5,"path":"../Aloha/Aloha/Util/Mutex.luau"}}')}}]);